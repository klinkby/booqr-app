# Booqr App - Agent Guidelines

This project is a Single Page Application (SPA) built with Svelte 5, designed for static site publishing.
It follows secure, accessible, and simply standards-first principles.

## Repository Overview for Agents

- **Framework**: SvelteKit with Svelte 5 in SPA mode, targeting static site deployments. Agents MUST prefer Svelte 5
	features, specifically **runes** (`$state`, `$derived`, `$effect`, `$props`, etc.) for reactivity and state
	management. For navigation, use `import { goto } from '$app/navigation'; goto(url);` instead of `window.location`.
- **Event Handling**: Use Svelte 5 event attributes (e.g., `onclick={handler}`, `onsubmit={handler}`) instead of Svelte
	4 `on:click`.
- **Styling**: Tailwind CSS with the official `forms` plugin ensures a minimal but extendable design system.
- **Components**: Prefer small, composable components. Use snippets (`{#snippet name(args)}...{/snippet}`) for reusable
	UI fragments within a component.
- **Tooling**: Keeps dependencies lean by relying on native ES2022 features and avoiding TypeScript tooling.
- **Verification**: Playwright is installed for end-to-end verification of the UI when needed.

Agents should focus on small, composable changes that align with these constraints and avoid introducing unnecessary
dependencies.

- **Build and Publishing**: Uses two-stage Docker builds for repeatability and compact, secure final images.
- **Web Server**: Static web server is lighttpd configured for security and minimal attack surface.
- **Bundling**: Keep the build output split into vendor and non-vendor bundles while targeting ES2022.


- **Never** manually edit `src/lib/api/**` files as they are auto generated by the `import-api` npm script.
- **API Client**: Generated using `openapi-typescript-codegen` with the `fetch` client. No axios dependency.
- **Collection Responses**: API collection endpoints return `{ items: T[] }` wrappers. Callers must access `.items` to
	get the array.

## API Client Configuration

- **Auth Setup**: Configured in `src/lib/auth.svelte.js` using an `AuthState` class with Svelte 5 runes (`$state`,
	`$derived`)
- **Initialization**: `src/routes/+layout.js` imports `$lib/auth.svelte.js` to configure `OpenAPI` settings on app start
- **Generated API Services**: Auto-generated services in `src/lib/api/services/` use the generated fetch-based
	`request()` function in `src/lib/api/core/request.js`
- **OpenAPI Config**: `OpenAPI.TOKEN`, `OpenAPI.WITH_CREDENTIALS`, and `OpenAPI.CREDENTIALS` are configured via
	`Object.defineProperty` getters bound to `auth` state

## Authentication

- **JWT Bearer Access Tokens**: Sent in `Authorization: Bearer ${token}` header for API requests
- **Refresh Tokens**: Stored in httponly cookies, automatically sent by browser with `credentials: 'include'`
- **Token Refresh Implementation**:
	- Uses `invokeApi()` wrapper in `src/lib/invokeApi.js` for automatic 401 refresh-and-retry
	- Usage: `await invokeApi(() => SomeService.someMethod(...))`
	- Catches `ApiError` with status 401, calls `AuthenticationService.refresh()`, then retries the operation
	- Coalesces concurrent refresh attempts with a shared `refreshPromise` to prevent multiple refresh calls
	- On refresh failure: clears auth state and redirects to `/login`
- **Token Management**: Centralized in `src/lib/auth.svelte.js` via the `auth` singleton. Use `auth.accessToken = token`
	to store and `auth.clear()` to remove.
- **Auth Flow**:
	1. Wrap API calls with `invokeApi()` for automatic token refresh
	2. On 401: `invokeApi` calls `AuthenticationService.refresh()` (httponly cookie sent automatically)
	3. If refresh succeeds: store new token via `auth.accessToken`, retry original operation
	4. If refresh fails: `auth.clear()`, redirect to `/login`
- **Token Storage**: Access tokens stored in `sessionStorage.access_token`
- **Token Validation**: JWT tokens decoded and validated for structure (3 dot-separated parts) and expiration (`exp`
	claim) before storage
- **Token Injection**: Generated `request()` function reads `OpenAPI.TOKEN` (bound to `auth.accessToken`) and adds
	`Authorization: Bearer ${token}` header automatically
- **Login**: Use `AuthenticationService.login()` with email/password, set `auth.accessToken` from
	`response.access_token`, clear password from memory. Redirect to `/` on success.
- **Logout**: Call `AuthenticationService.logout()`, `auth.clear()`, redirect to home page via `goto('/')`
- **Auth State**: Reactive `auth.isLoggedIn` (derived from token presence) drives UI state (e.g., Login/Logout toggle in
	nav)
- **Return URL After Re-authentication**: When token refresh fails and user is redirected to login, they should return
	to their original page after successful login:
	- **Pattern**: Capture current URL → Pass as query param to login → Redirect back after login
	- **Implementation in `invokeApi.js`**: On refresh failure, capture
		`window.location.pathname + window.location.search` and redirect to
		`/login?returnUrl=${encodeURIComponent(returnUrl)}`
	```js
	async function doRefresh() {
		try {
			const response = await AuthenticationService.refresh();
			auth.accessToken = response.access_token;
		} catch (error) {
			auth.clear();
			// Capture current URL to return after re-authentication
			const returnUrl = window.location.pathname + window.location.search;
			await goto(`/login?returnUrl=${encodeURIComponent(returnUrl)}`);
			throw error;
		}
	}
	```
	- **Implementation in login page**: Read `returnUrl` from query params using `$derived` with `$page` store (Svelte 5
		best practice), redirect to captured URL after successful login
	```js
	import { page } from '$app/stores';

	// Use $derived for reactive access to URL search params
	let returnUrl = $derived($page.url.searchParams.get('returnUrl') || '/');

	async function handleSubmit() {
		// ... authentication logic ...
		if (auth.isLoggedIn) {
			await goto(returnUrl);  // Return to original page
		}
	}
	```
	- **Svelte 5 Note**: Using `$page` store in Svelte 5 components with runes triggers an informational deprecation
		warning. This is expected during the SvelteKit transition period and doesn't affect functionality. The
		`$derived($page.url.searchParams.get(...))` pattern is the current recommended approach until SvelteKit provides the
		planned `SvelteURL` reactive API.
- **Sample JWT token**:

```json
{
  "sub": "1",
  "email": "m@kli.dk",
  "role": "Customer",
  "nbf": 1770475680,
  "exp": 1770479280,
  "iat": 1770475680,
  "iss": "booqr",
  "aud": "https://www.booqr.dk"
}
```

## Security Considerations (OWASP Aligned)

- **Secrets Management**: **NEVER** store secrets, credentials, or API keys in code files. ALWAYS use `.env` file (
	gitignored) for sensitive data.
- **Authentication**: JWT access tokens are stored in `sessionStorage`. Refresh tokens are stored in `HttpOnly` cookies.
- **CSRF Protection**: Refresh tokens are stored in `HttpOnly`, `SameSite=Strict` cookies. The API client uses
	`credentials: 'include'` for authenticated requests.
- **XSS Prevention**: Svelte 5 automatically escapes content. However, avoid `{@html ...}` unless the content is
	explicitly sanitized. Use `DOMPurify` if parsing user-provided HTML is necessary.
- **Content Security Policy (CSP)**: Ensure the application can run with a strict CSP. Avoid inline styles and scripts
	where possible.
- **Token Validation**: All tokens validated for JWT structure before use or storage.
- **Error Handling**: Generic error messages displayed to users to prevent information disclosure (e.g., "Authentication
	failed" instead of "User not found").
- **No Console Logging**: Sensitive data (tokens, passwords, PII) MUST NOT be logged to the console.
- **Duplicate Interceptors**: Protected against multiple interceptor registrations.
- **Credentials Scope**: `withCredentials: true` only set for `/api/` paths to limit cookie exposure.
- **Password Handling**: Passwords cleared from memory (`password = ''`) after successful login.
- **URL Validation**: Strict path checking for API requests to prevent credential leakage to external domains.
- **Input Validation**: Validate all user input on the client side before submission and ensure the API performs
	server-side validation.

## API Pagination

- **Collection GET endpoints**: Support `Start` (index) and `Num` (page size) parameters for pagination
- **Default page size**: Always use `Num=100` (maximum result set size)
- **Pagination**: If a response returns exactly `Num` results, then next page can be fetched with `Start = Start + Num`.

## Application Structure

- **Routes**: SvelteKit file-based routing in `src/routes/`
	- `/` - Home page
    - `/profile` - My Profile page (any logged-in user) - edit name/phone, request password reset
	- `/login` - Login form with email/password fields, uses Form component
	- `/admin/` - Protected admin area (requires login + Employee role)
	- `/admin/calendar` - Interactive calendar for managing vacancies:
		- Weekly time grid view (6 AM - 10 PM)
		- Click-to-create: Employees click time slots to create vacancies
		- Side panel form: VacancyForm appears in right panel (384px width)
		- Auto-refresh: Calendar updates after creating vacancies
		- Uses Calendar component with Interaction plugin for click handling
	- `/admin/services` - Service list page with Create button and Edit actions
	- `/admin/services/new` - Create service form page
	- `/admin/services/[id]` - Edit service form page (dynamic route)
- **Layout**: Top-level navigation in `src/routes/+layout.svelte` with Home and Login/Logout links. Admin link shown
	only to employees (`auth.isEmployee`).
	- **Responsive Layout**: Main content constrained with `container mx-auto px-4 py-8 max-w-7xl` for consistent
		centering and max-width (1280px) across all pages
	- **Header/Footer**: Use same responsive constraints for visual alignment
- **Navigation**: Login/Logout toggle based on `sessionStorage.access_token` presence
- **Shared Utilities**: Place reusable functions in `src/lib/` and export via `src/lib/index.js`
- **Reusable Components**: Place shared Svelte components in `src/lib/components/` and export via `src/lib/index.js`

## Admin Section

- **Auth Guard**: `src/routes/admin/+layout.svelte` redirects unauthenticated users to `/login` via `$effect` and only
	renders children for logged-in employees. Non-employee users see "Access denied".
- **Nav Link**: The top-level layout conditionally shows the Admin link when `auth.isEmployee` is true.
- **Adding Admin Pages**: Create new routes under `src/routes/admin/` — they automatically inherit the auth guard from
	the admin layout.

### CRUD Pattern for Admin Resources

When building admin CRUD interfaces, follow this pattern used in the Services implementation:

**List Page** (`/admin/services/+page.svelte`):

- Use `PaginatedTable` component with `columns`, `fetchCommand`, and `onedit` callback
- Add a "Create" button in the header that navigates to `/admin/services/new`
- Wire `onedit` to navigate to `/admin/services/{id}`

**Form Page** (`/admin/services/[id]/+page.svelte`):

- Use dynamic route with `[id]` parameter
- Derive `isEdit` mode from `id !== 'new'`
- Use `Form` component with fields injected as children
- Load existing data with `onMount` for edit mode
- Call appropriate API service method (`addX` for create, `updateX` for edit)
- Provide `oncancel` callback to navigate back to list page
- Use `max-w-2xl` wrapper for form to constrain width

## Reusable Components (`src/lib/components/`)

### DataTable (`src/lib/components/DataTable.svelte`)

A generic, accessible data table component for listing and paging through records with optional row actions.

**Import**: `import { DataTable } from '$lib';`

**Props** (via `$props()`):
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `columns` | `Array<{ key: string, label: string }>` | required | Column definitions — `key` maps to row property,
`label` is header text |
| `rows` | `Array<object>` | required | Data rows to display |
| `hasPreviousPage` | `boolean` | `false` | Enables Previous button |
| `hasNextPage` | `boolean` | `false` | Enables Next button |
| `onedit` | `(row) => void` | `undefined` | Edit callback — if omitted, no Edit button shown |
| `ondelete` | `(row) => void` | `undefined` | Delete callback — if omitted, no Delete button shown |
| `onnextpage` | `() => void` | `undefined` | Next page callback |
| `onpreviouspage` | `() => void` | `undefined` | Previous page callback |

**Conditional rendering**:

- The Actions column only renders if `onedit` or `ondelete` is provided.
- The pagination nav only renders if `onnextpage` or `onpreviouspage` is provided.

**Styling**: Uses the app's gray/indigo Tailwind palette — gray-50 header backgrounds, indigo-600 action links and
paging buttons, `disabled:opacity-50` for disabled paging state.

**Usage example**:

```svelte
<script>
  import { DataTable } from '$lib';

  const columns = [
    { key: 'name', label: 'Name' },
    { key: 'duration', label: 'Duration' }
  ];
  let rows = $state([]);
</script>

<DataTable
  {columns}
  {rows}
  hasNextPage={true}
  onedit={(row) => console.log('edit', row)}
  ondelete={(row) => console.log('delete', row)}
  onnextpage={() => loadNext()}
  onpreviouspage={() => loadPrev()}
/>
```

### Form (`src/lib/components/Form.svelte`)

A semantic, accessible form wrapper component that handles submission, error display, loading states, and action
buttons. Consumers inject their own form fields as children.

**Import**: `import { Form } from '$lib';`

**Props** (via `$props()`):
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `legend` | `string` | required | Screen-reader text for the `<fieldset>` (visually hidden with `sr-only`) |
| `error` | `string \| null` | `null` | Error message to display above the form |
| `loading` | `boolean` | `false` | Disables fieldset and buttons, shows loading text on submit |
| `submitLabel` | `string` | `'Submit'` | Label for the submit button |
| `onsubmit` | `(event) => void` | required | Submit handler — `preventDefault` is handled by the component |
| `oncancel` | `() => void` | `undefined` | Cancel callback — if omitted, no Cancel button shown |
| `children` | snippet | required | Form fields to render inside the fieldset |

**Features**:

- Automatically calls `event.preventDefault()` on submit
- Error alert stays in DOM (toggled with `class:hidden`) for reliable `aria-live` announcements
- Submit button shows "Please wait…" during loading
- Both submit and cancel buttons disabled during loading
- Uses `novalidate` on form for custom validation handling

**Styling**: Uses app's gray/indigo Tailwind palette — red error alerts, gray Cancel button, indigo Submit button,
consistent focus rings.

**Usage example**:

```svelte
<script>
  import { Form } from '$lib';
  import { goto } from '$app/navigation';

  let name = $state('');
  let error = $state(null);
  let loading = $state(false);

  async function handleSubmit() {
    error = null;
    loading = true;
    try {
      await SomeService.create({ name });
      goto('/success');
    } catch (err) {
      error = err.message || 'Failed to save. Please try again.';
    } finally {
      loading = false;
    }
  }

  function handleCancel() {
    goto('/back');
  }
</script>

<Form
  legend="Create item"
  {error}
  {loading}
  submitLabel="Create"
  onsubmit={handleSubmit}
  oncancel={handleCancel}
>
  <div>
    <label for="name" class="block text-sm font-medium text-gray-700 mb-1">
      Name
    </label>
    <input
      id="name"
      name="name"
      type="text"
      required
      bind:value={name}
      class="block w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
    />
  </div>
</Form>
```

### Calendar (`src/lib/components/Calendar.svelte`)

A weekly calendar view component that displays time-based events using the `@event-calendar/core` library. The component
is purely presentational (no IO) and relies on parent components to provide event data.

**Import**: `import { Calendar } from '$lib';`

**Required Plugin**: To enable click interactions, the `Interaction` plugin from `@event-calendar/core` must be included
in the Calendar component:

```js
import { Calendar, TimeGrid, Interaction } from '@event-calendar/core';

<Calendar plugins={[TimeGrid, Interaction]} {options} />
```

**Props** (via `$props()`):
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `events` | `Array<object>` | `[]` | Array of event objects in Event Calendar format |
| `onDatesChange` | `(info) => void` | `undefined` | Callback when user navigates to different week — receives
`{start, end, startStr, endStr, view}` |
| `onDateClick` | `(info) => void` | `undefined` | Callback when user clicks on a date/time slot — receives
`{date, dateStr, allDay, resource, jsEvent, view}`. **Requires Interaction plugin**. |

**Event Object Format**:
Events must be provided in Event Calendar format:

```js
{
  id: string | number,           // Unique identifier
  start: string | Date,           // ISO8601 string or Date object
  end: string | Date,             // ISO8601 string or Date object
  title: string,                  // Display text
  backgroundColor: string,        // CSS color (optional)
  textColor: string,              // CSS color (optional)
  extendedProps: object           // Custom data (optional)
}
```

**Configuration**:

- Weekly view with hourly time grid (6 AM - 10 PM)
- Week starts on Monday
- No all-day slot (optimized for time-specific events)
- Navigation toolbar: Previous, Next, Today buttons

**Transforming API Data**:
API `CalendarEvent` objects must be transformed to Event Calendar format:

```js
function transformVacancyToEvent(vacancy) {
  return {
    id: vacancy.id,
    start: vacancy.startTime,      // ISO8601 string
    end: vacancy.endTime,          // ISO8601 string
    title: vacancy.bookingId ? 'Booked' : 'Available',
    classNames: vacancy.bookingId
      ? ['!bg-red-500', '!text-white', '!border-red-600']
      : ['!bg-green-500', '!text-white', '!border-green-600'],
    extendedProps: {
      employeeId: vacancy.employeeId,
      locationId: vacancy.locationId,
      bookingId: vacancy.bookingId
    }
  };
}
```

**Usage example** (from `/admin/calendar`):

```svelte
<script>
  import { Calendar } from '$lib';
  import { VacancyService } from '$lib/api';
  import { invokeApi } from '$lib/invokeApi';
  import { auth } from '$lib';

  let events = $state([]);
  let showForm = $state(false);

  async function fetchVacancies(startDate, endDate) {
    const response = await invokeApi(() =>
      VacancyService.getVacancies(
        startDate.toISOString(),
        endDate.toISOString(),
        0,
        100
      )
    );
    events = response.items.map(transformVacancyToEvent);
  }

  function handleDatesChange(info) {
    fetchVacancies(info.start, info.end);
  }

  function handleDateClick(info) {
    // Pre-fill form with clicked time (1-hour duration)
    const startDate = new Date(info.date);
    const endDate = new Date(startDate.getTime() + 60 * 60 * 1000);
    formData.startTime = startDate.toISOString().slice(0, 16);
    formData.endTime = endDate.toISOString().slice(0, 16);
    showForm = true;
  }
</script>

<!-- Flex layout with calendar and side panel -->
<div class="flex gap-6">
  <div class="flex-1 min-w-0">
    <Calendar
      {events}
      onDatesChange={handleDatesChange}
      onDateClick={handleDateClick}
    />
  </div>

  {#if showForm}
    <div class="w-96 shrink-0">
      <!-- VacancyForm appears here -->
    </div>
  {/if}
</div>
```

**Important**: The Calendar component in `/src/lib/components/Calendar.svelte` must include the Interaction plugin for
`onDateClick` to work:

```js
import { Calendar, TimeGrid, Interaction } from '@event-calendar/core';

<Calendar plugins={[TimeGrid, Interaction]} {options} />
```

**Styling**:

- Uses Event Calendar's default styles from `@event-calendar/core/index.css`
- Component is unstyled (no wrapper) — parent pages can wrap with Tailwind utilities as needed
- Event styling uses Tailwind classes via `classNames` property with `!important` modifier to override defaults
- Example: `classNames: ['!bg-red-500', '!text-white', '!border-red-600']`

### VacancyForm (`src/lib/components/VacancyForm.svelte`)

A form component for creating new vacancies with location and employee assignment. Uses the Form component internally
and is displayed as a side panel in the admin calendar.

**Import**: `import { VacancyForm } from '$lib';`

**Props** (via `$props()` with `$bindable`):
| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `startTime` | `string` (bindable) | `''` | ISO8601 datetime string for vacancy start (format: `YYYY-MM-DDTHH:mm`) |
| `endTime` | `string` (bindable) | `''` | ISO8601 datetime string for vacancy end |
| `locationId` | `string` (bindable) | `''` | Selected location ID |
| `employeeId` | `string` (bindable) | `''` | Selected employee ID (required) |
| `locations` | `Array<object>` | `[]` | Array of location objects with `{id, name}` |
| `employees` | `Array<object>` | `[]` | Array of employee objects with `{id, name, email}` |
| `error` | `string \| null` | `null` | Error message to display |
| `loading` | `boolean` | `false` | Loading state for submit button |
| `onsubmit` | `(event) => void` | required | Submit handler |
| `oncancel` | `() => void` | required | Cancel handler |

**Features**:

- Uses `$bindable` props for two-way data binding (Svelte 5 pattern)
- Wraps Form component with pre-styled sticky panel layout
- Datetime-local inputs for start/end times
- Location and employee dropdowns with validation
- All fields required for submission

**Usage example** (from `/admin/calendar`):

```svelte
<script>
  import { VacancyForm } from '$lib';

  let formData = $state({
    startTime: '',
    endTime: '',
    locationId: '',
    employeeId: ''
  });
  let locations = $state([]);
  let employees = $state([]);
  let formError = $state(null);
  let formLoading = $state(false);

  async function handleSubmit() {
    // Create vacancy via API
  }

  function handleCancel() {
    showForm = false;
  }
</script>

<VacancyForm
  bind:startTime={formData.startTime}
  bind:endTime={formData.endTime}
  bind:locationId={formData.locationId}
  bind:employeeId={formData.employeeId}
  {locations}
  {employees}
  error={formError}
  loading={formLoading}
  onsubmit={handleSubmit}
  oncancel={handleCancel}
/>
```

**Styling**: Includes sticky positioning (`sticky top-4`) and gray panel background for side panel display.

**Adding new reusable components**: Create a `.svelte` file in `src/lib/components/`, then add a
`export { default as ComponentName } from './components/ComponentName.svelte';` line to `src/lib/index.js`.

## Semantic HTML5 & Accessibility (required)

Agents MUST use semantic HTML5 markup and follow accessibility standards on every page and component. This section is
normative: code reviews and automated checks should reject non-semantic or inaccessible patterns.

Goals

- Improve screen-reader, keyboard and assistive-technology UX.
- Preserve a strict and meaningful document outline and landmarks.
- Prefer native semantics (button, a, form, label, fieldset, legend, table, caption, nav, header, main, footer, article,
	section, aside, figure, figcaption) over divs and role-based hacks.

Checklist (apply to pages and components)

- Landmarks: include a single `<main>` per page plus appropriate `<header>`, `<nav>`, and `<footer>` or `<aside>` for
	complementary content.
- Skip link: provide a "Skip to content" link at the top (before `<header>`) for keyboard users, targeting
	`<main id="main">`.
- Headings: use H1–H6 as a logical outline; exactly one H1 per page (the route's title).
- Links and buttons: use `<a href>` for navigation (including external links) and `<button>` for actions. Avoid
	`tabindex` and role overrides to make interactive elements natively focusable.
- Forms: every control MUST have a associated `<label>` (via `for` attribute matching `id`); group related controls with
	`<fieldset>` and `<legend>`.
- Images: use `<img alt="...">` for informative images; use empty `alt=""` for decorative images. Prefer
	`<figure><img ...><figcaption>...</figcaption></figure>` for descriptive content.
- Tables: include `<caption>` and use `<thead>`, `<tbody>`, `<th scope="col|row">` for data tables.
- ARIA: use ARIA only to fill gaps; do not duplicate native semantics. Prefer `aria-live` for dynamic announcements and
	`role="status"` for non-blocking updates.
- Focus management: ensure sensible focus order, visible focus styles, and restore focus on route changes when
	appropriate.
- Keyboard access: all interactive functionality MUST be operable via keyboard (Tab, Enter, Space, Arrow keys).
- Color & contrast: follow WCAG AA contrast requirements (4.5:1 for normal text); avoid using color alone to convey
	meaning.
- Avoid using `role="button"` on non-interactive elements; instead replace with `<button>`.
- Avoid duplicate IDs; use unique IDs for label bindings.

Svelte-specific guidelines

- Use native elements inside Svelte components; wrap behavior in actions or runes rather than replacing semantics.
- For client-side navigation use: import { goto } from '$app/navigation'; goto(url); keep links as <a href="/path"> when
	possible to preserve semantics and middle-click/open-in-new-tab behavior.
- Example layout snippet (semantic structure):
	- Ensure this pattern appears in top-level layout components.
	- Use one H1 in each route's page component.

	```html
	<!-- Example: semantic layout in +layout.svelte -->
	<!-- filepath: src/routes/+layout.svelte -->
	<script>
		let { children } = $props();
	</script>

	<a class="sr-only focus:not-sr-only" href="#main">Skip to content</a>
	<header>
		<nav aria-label="Primary navigation">
			<a href="/">Home</a>
			<a href="/calendar">Calendar</a>
			<a href="/login">Login</a>
		</nav>
	</header>

	<main id="main">
		<!-- Page content (each page should have one H1) -->
		{@render children()}
	</main>

	<footer>
		<small>&copy; {new Date().getFullYear()} Booqr</small>
	</footer>
	```

- Forms example (semantic, accessible, Svelte 5):
	```html
	<!-- filepath: src/routes/login/+page.svelte -->
	<script>
		let email = $state('');
		let password = $state('');
		let errorMessage = $state('');
		let loading = $state(false);

		async function handleSubmit(event) {
			event.preventDefault();
			// ... login logic
		}
	</script>

	<form onsubmit={handleSubmit} novalidate>
		<fieldset disabled={loading}>
			<legend>Sign in</legend>

			<div class="field">
				<label for="email">Email</label>
				<input id="email" name="email" type="email" bind:value={email} required autocomplete="email" />
			</div>

			<div class="field">
				<label for="password">Password</label>
				<input id="password" name="password" type="password" bind:value={password} required autocomplete="current-password" />
			</div>

			<button type="submit" disabled={loading}>
				{loading ? 'Signing in...' : 'Sign in'}
			</button>
		</fieldset>

		{#if errorMessage}
			<div role="status" aria-live="polite" class="error">{errorMessage}</div>
		{/if}
	</form>
	```

Testing & verification

- Add automated checks in CI:
	- Playwright tests should assert presence of landmarks, skip link, and heading structure (e.g., expect(nav)
		.toBeVisible(), expect('main > h1').toHaveCount(1)).
	- Run axe-core or Lighthouse CI in tests to detect accessibility regressions.
- Use Playwright to verify keyboard navigation and that critical elements are reachable and announced:
	- Test skip link focus and activation.
	- Test form labels are associated and validation messages are exposed via aria-live or role=status.

Notes & enforcement

- Prefer progressive enhancement: semantic markup must work without JS.
- Replace decorative patterns like <div role="button"> with native elements.
- Document any exception and justify ARIA usage in PR description.
- Reviewers must block PRs that remove semantics or introduce inaccessible patterns.

## Verification

- **End-to-End Verification**: Playwright tests in `e2e/` verify UI behavior and API responses.
- **Unit tests**: This project does NOT include unit tests.

## Playwright Testing Principles

- **Environment Variables**: ALWAYS store test credentials and secrets in `.env` file (gitignored), NEVER hardcode in
	test files. Document the required variables in a `.env.example` file in the project root so new developers know what
	to configure.
	- Required variables for Playwright tests:
		- `TEST_EMAIL`
		- `TEST_PASSWORD`

	Example `.env.example`:
	```env
	TEST_EMAIL=your-test-user@example.com
	TEST_PASSWORD=your-secure-test-password
- **Configuration**: Load environment variables in `playwright.config.js` using `dotenv.config()`
- **Test Structure**: Each test should be self-contained and clean up after itself
- **Navigation**: Use `baseURL` in config for cleaner test URLs, navigate with `page.goto('/')`
- **Assertions**:
	- Use `expect(page).toHaveURL()` for navigation assertions
	- Use `expect(locator).toBeVisible()` for element visibility
	- Use `expect(locator).not.toBeVisible()` for hidden elements
	- Use `page.evaluate()` to access browser storage (sessionStorage, localStorage)
- **Form Interaction**: Use `page.fill()` for inputs and `page.click()` for buttons
- **Selectors**: Prefer semantic selectors (e.g., `nav a[href="/login"]`, `input[name="email"]`)
- **Security**: Never log credentials or tokens in test output
- **Test Flow**: Structure tests to mirror user behavior:
	1. Setup (clear cookies, navigate)
	2. Action (click, fill, submit)
	3. Assertion (verify URL, verify DOM, verify storage)
