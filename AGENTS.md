# Booqr App - Agent Guidelines

This project is a Single Page Application (SPA) built with Svelte 5, designed for static site publishing. 
It follows secure, accessible, and simply standards-first principles.

## Repository Overview for Agents

- **Framework**: SvelteKit with Svelte 5 in SPA mode, targeting static site deployments. Agents MUST prefer Svelte 5 features, specifically **runes** (`$state`, `$derived`, `$effect`, `$props`, etc.) for reactivity and state management. For navigation, use `import { goto } from '$app/navigation'; goto(url);` instead of `window.location`.
- **Event Handling**: Use Svelte 5 event attributes (e.g., `onclick={handler}`, `onsubmit={handler}`) instead of Svelte 4 `on:click`.
- **Styling**: Tailwind CSS with the official `forms` plugin ensures a minimal but extendable design system.
- **Components**: Prefer small, composable components. Use snippets (`{#snippet name(args)}...{/snippet}`) for reusable UI fragments within a component.
- **Tooling**: Keeps dependencies lean by relying on native ES2022 features and avoiding TypeScript tooling.
- **Verification**: Playwright is installed for end-to-end verification of the UI when needed.

Agents should focus on small, composable changes that align with these constraints and avoid introducing unnecessary dependencies.

- **Build and Publishing**: Uses two-stage Docker builds for repeatability and compact, secure final images.
- **Web Server**: Static web server is lighttpd configured for security and minimal attack surface.
- **Bundling**: Keep the build output split into vendor and non-vendor bundles while targeting ES2022.


- **Never** manually edit `src/lib/api/**` files as they are auto generated by the `import-api` npm script.
- **API Client**: Generated using `openapi-typescript-codegen` with the `fetch` client. No axios dependency.
- **Collection Responses**: API collection endpoints return `{ items: T[] }` wrappers. Callers must access `.items` to get the array.

## API Client Configuration
- **Auth Setup**: Configured in `src/lib/auth.svelte.js` using an `AuthState` class with Svelte 5 runes (`$state`, `$derived`)
- **Initialization**: `src/routes/+layout.js` imports `$lib/auth.svelte.js` to configure `OpenAPI` settings on app start
- **Generated API Services**: Auto-generated services in `src/lib/api/services/` use the generated fetch-based `request()` function in `src/lib/api/core/request.js`
- **OpenAPI Config**: `OpenAPI.TOKEN`, `OpenAPI.WITH_CREDENTIALS`, and `OpenAPI.CREDENTIALS` are configured via `Object.defineProperty` getters bound to `auth` state

## Authentication
- **JWT Bearer Access Tokens**: Sent in `Authorization: Bearer ${token}` header for API requests
- **Refresh Tokens**: Stored in httponly cookies, automatically sent by browser with `credentials: 'include'`
- **Token Refresh Implementation**:
  - Uses `invokeApi()` wrapper in `src/lib/invokeApi.js` for automatic 401 refresh-and-retry
  - Usage: `await invokeApi(() => SomeService.someMethod(...))`
  - Catches `ApiError` with status 401, calls `AuthenticationService.refresh()`, then retries the operation
  - Coalesces concurrent refresh attempts with a shared `refreshPromise` to prevent multiple refresh calls
  - On refresh failure: clears auth state and redirects to `/login`
- **Token Management**: Centralized in `src/lib/auth.svelte.js` via the `auth` singleton. Use `auth.accessToken = token` to store and `auth.clear()` to remove.
- **Auth Flow**:
  1. Wrap API calls with `invokeApi()` for automatic token refresh
  2. On 401: `invokeApi` calls `AuthenticationService.refresh()` (httponly cookie sent automatically)
  3. If refresh succeeds: store new token via `auth.accessToken`, retry original operation
  4. If refresh fails: `auth.clear()`, redirect to `/login`
- **Token Storage**: Access tokens stored in `sessionStorage.access_token`
- **Token Validation**: JWT tokens decoded and validated for structure (3 dot-separated parts) and expiration (`exp` claim) before storage
- **Token Injection**: Generated `request()` function reads `OpenAPI.TOKEN` (bound to `auth.accessToken`) and adds `Authorization: Bearer ${token}` header automatically
- **Login**: Use `AuthenticationService.login()` with email/password, set `auth.accessToken` from `response.access_token`, clear password from memory. Redirect to `/` on success.
- **Logout**: Call `AuthenticationService.logout()`, `auth.clear()`, redirect to home page via `goto('/')`
- **Auth State**: Reactive `auth.isLoggedIn` (derived from token presence) drives UI state (e.g., Login/Logout toggle in nav)

## Security Considerations (OWASP Aligned)
- **Secrets Management**: **NEVER** store secrets, credentials, or API keys in code files. ALWAYS use `.env` file (gitignored) for sensitive data.
- **Authentication**: JWT access tokens are stored in `sessionStorage`. Refresh tokens are stored in `HttpOnly` cookies.
- **CSRF Protection**: Refresh tokens are stored in `HttpOnly`, `SameSite=Strict` cookies. The API client uses `credentials: 'include'` for authenticated requests.
- **XSS Prevention**: Svelte 5 automatically escapes content. However, avoid `{@html ...}` unless the content is explicitly sanitized. Use `DOMPurify` if parsing user-provided HTML is necessary.
- **Content Security Policy (CSP)**: Ensure the application can run with a strict CSP. Avoid inline styles and scripts where possible.
- **Token Validation**: All tokens validated for JWT structure before use or storage.
- **Error Handling**: Generic error messages displayed to users to prevent information disclosure (e.g., "Authentication failed" instead of "User not found").
- **No Console Logging**: Sensitive data (tokens, passwords, PII) MUST NOT be logged to the console.
- **Duplicate Interceptors**: Protected against multiple interceptor registrations.
- **Credentials Scope**: `withCredentials: true` only set for `/api/` paths to limit cookie exposure.
- **Password Handling**: Passwords cleared from memory (`password = ''`) after successful login.
- **URL Validation**: Strict path checking for API requests to prevent credential leakage to external domains.
- **Input Validation**: Validate all user input on the client side before submission and ensure the API performs server-side validation.

## API Pagination
- **Collection GET endpoints**: Support `Start` (index) and `Num` (page size) parameters for pagination
- **Default page size**: Always use `Num=100` (maximum result set size)
- **Pagination**: If a response returns exactly `Num` results, then next page can be fetched with `Start = Start + Num`.

## Application Structure
- **Routes**: SvelteKit file-based routing in `src/routes/`
  - `/` - Home page
  - `/calendar` - Displays all vacancies using `VacancyService.getVacancies()` with auto-pagination
  - `/login` - Login form with email/password fields
- **Layout**: Top-level navigation in `src/routes/+layout.svelte` with Home, Calendar, and Login/Logout links
- **Navigation**: Login/Logout toggle based on `sessionStorage.access_token` presence
- **Shared Utilities**: Place reusable functions in `src/lib/` and export via `src/lib/index.js`

## Semantic HTML5 & Accessibility (required)

Agents MUST use semantic HTML5 markup and follow accessibility standards on every page and component. This section is normative: code reviews and automated checks should reject non-semantic or inaccessible patterns.

Goals
- Improve screen-reader, keyboard and assistive-technology UX.
- Preserve a strict and meaningful document outline and landmarks.
- Prefer native semantics (button, a, form, label, fieldset, legend, table, caption, nav, header, main, footer, article, section, aside, figure, figcaption) over divs and role-based hacks.

Checklist (apply to pages and components)
- Landmarks: include a single `<main>` per page plus appropriate `<header>`, `<nav>`, and `<footer>` or `<aside>` for complementary content.
- Skip link: provide a "Skip to content" link at the top (before `<header>`) for keyboard users, targeting `<main id="main">`.
- Headings: use H1â€“H6 as a logical outline; exactly one H1 per page (the route's title).
- Links and buttons: use `<a href>` for navigation (including external links) and `<button>` for actions. Avoid `tabindex` and role overrides to make interactive elements natively focusable.
- Forms: every control MUST have a associated `<label>` (via `for` attribute matching `id`); group related controls with `<fieldset>` and `<legend>`.
- Images: use `<img alt="...">` for informative images; use empty `alt=""` for decorative images. Prefer `<figure><img ...><figcaption>...</figcaption></figure>` for descriptive content.
- Tables: include `<caption>` and use `<thead>`, `<tbody>`, `<th scope="col|row">` for data tables.
- ARIA: use ARIA only to fill gaps; do not duplicate native semantics. Prefer `aria-live` for dynamic announcements and `role="status"` for non-blocking updates.
- Focus management: ensure sensible focus order, visible focus styles, and restore focus on route changes when appropriate.
- Keyboard access: all interactive functionality MUST be operable via keyboard (Tab, Enter, Space, Arrow keys).
- Color & contrast: follow WCAG AA contrast requirements (4.5:1 for normal text); avoid using color alone to convey meaning.
- Avoid using `role="button"` on non-interactive elements; instead replace with `<button>`.
- Avoid duplicate IDs; use unique IDs for label bindings.

Svelte-specific guidelines
- Use native elements inside Svelte components; wrap behavior in actions or runes rather than replacing semantics.
- For client-side navigation use: import { goto } from '$app/navigation'; goto(url); keep links as <a href="/path"> when possible to preserve semantics and middle-click/open-in-new-tab behavior.
- Example layout snippet (semantic structure):
  - Ensure this pattern appears in top-level layout components.
  - Use one H1 in each route's page component.

  ```html
  <!-- Example: semantic layout in +layout.svelte -->
  <!-- filepath: src/routes/+layout.svelte -->
  <script>
    let { children } = $props();
  </script>

  <a class="sr-only focus:not-sr-only" href="#main">Skip to content</a>
  <header>
    <nav aria-label="Primary navigation">
      <a href="/">Home</a>
      <a href="/calendar">Calendar</a>
      <a href="/login">Login</a>
    </nav>
  </header>

  <main id="main">
    <!-- Page content (each page should have one H1) -->
    {@render children()}
  </main>

  <footer>
    <small>&copy; {new Date().getFullYear()} Booqr</small>
  </footer>
  ```

- Forms example (semantic, accessible, Svelte 5):
  ```html
  <!-- filepath: src/routes/login/+page.svelte -->
  <script>
    let email = $state('');
    let password = $state('');
    let errorMessage = $state('');
    let loading = $state(false);

    async function handleSubmit(event) {
      event.preventDefault();
      // ... login logic
    }
  </script>

  <form onsubmit={handleSubmit} novalidate>
    <fieldset disabled={loading}>
      <legend>Sign in</legend>

      <div class="field">
        <label for="email">Email</label>
        <input id="email" name="email" type="email" bind:value={email} required autocomplete="email" />
      </div>

      <div class="field">
        <label for="password">Password</label>
        <input id="password" name="password" type="password" bind:value={password} required autocomplete="current-password" />
      </div>

      <button type="submit" disabled={loading}>
        {loading ? 'Signing in...' : 'Sign in'}
      </button>
    </fieldset>

    {#if errorMessage}
      <div role="status" aria-live="polite" class="error">{errorMessage}</div>
    {/if}
  </form>
  ```

Testing & verification
- Add automated checks in CI:
  - Playwright tests should assert presence of landmarks, skip link, and heading structure (e.g., expect(nav).toBeVisible(), expect('main > h1').toHaveCount(1)).
  - Run axe-core or Lighthouse CI in tests to detect accessibility regressions.
- Use Playwright to verify keyboard navigation and that critical elements are reachable and announced:
  - Test skip link focus and activation.
  - Test form labels are associated and validation messages are exposed via aria-live or role=status.

Notes & enforcement
- Prefer progressive enhancement: semantic markup must work without JS.
- Replace decorative patterns like <div role="button"> with native elements.
- Document any exception and justify ARIA usage in PR description.
- Reviewers must block PRs that remove semantics or introduce inaccessible patterns.

## Verification
- **End-to-End Verification**: Playwright tests in `e2e/` verify UI behavior and API responses.
- **Unit tests**: This project does NOT include unit tests.

## Playwright Testing Principles
- **Environment Variables**: ALWAYS store test credentials and secrets in `.env` file (gitignored), NEVER hardcode in test files. Document the required variables in a `.env.example` file in the project root so new developers know what to configure.
  - Required variables for Playwright tests:
    - `TEST_EMAIL`
    - `TEST_PASSWORD`

  Example `.env.example`:
  ```env
  TEST_EMAIL=your-test-user@example.com
  TEST_PASSWORD=your-secure-test-password
- **Configuration**: Load environment variables in `playwright.config.js` using `dotenv.config()`
- **Test Structure**: Each test should be self-contained and clean up after itself
- **Navigation**: Use `baseURL` in config for cleaner test URLs, navigate with `page.goto('/')`
- **Assertions**: 
  - Use `expect(page).toHaveURL()` for navigation assertions
  - Use `expect(locator).toBeVisible()` for element visibility
  - Use `expect(locator).not.toBeVisible()` for hidden elements
  - Use `page.evaluate()` to access browser storage (sessionStorage, localStorage)
- **Form Interaction**: Use `page.fill()` for inputs and `page.click()` for buttons
- **Selectors**: Prefer semantic selectors (e.g., `nav a[href="/login"]`, `input[name="email"]`)
- **Security**: Never log credentials or tokens in test output
- **Test Flow**: Structure tests to mirror user behavior:
  1. Setup (clear cookies, navigate)
  2. Action (click, fill, submit)
  3. Assertion (verify URL, verify DOM, verify storage)
